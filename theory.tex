\section{Pre-processing Techniques for \ltlf Synthesis}
In this section, we introduce some pre-processing techniques for \ltlf synthesis, which can be evaluated immediately on the given \ltlf formula w.r.t. the atomic set $\P=\X\cup\Y$. First, the following Lemma is straightforward according to the \ltlf semantics and Definition \ref{def:synthesis}.

\begin{theorem}\label{thm:sat-syn}
	If the \ltlf formula $\phi$ is unsatisfiable, then $\phi$ is not realizable; If $\phi$ is valid, then $\phi$ is realizable.
\end{theorem}
Theorem~\ref{thm:sat-syn} suggests that an unsatisfiable/valid \ltlf formula is not quite useful as a synthesis specification in practice. 
To that end, an extant \ltlf-satisfiability solver, e.g., \aaltaf~\cite{LRPZV19}, can be used to check the satisfiability/validity of the formula upon the synthesis. We now define the $\satOnce$ predicate for further use. 

\begin{definition}\label{def:satOnce}
Given an \ltlf formula $\phi$ and $\omega\in 2^{\P}$, we define the predicate $\satOnce (\omega, \phi)$ is true iff 
\begin{itemize}
	\item $\phi$ is $\tt$; or
	\item $\phi \in \omega$ when $\phi$ is an atom; or 
	\item $\neg \satOnce (\omega, \psi)$ is true when $\phi = \neg\psi$;
	\item $\satOnce (\omega, \phi_1)$ and $\satOnce (\omega, \phi_2)$ are true, when $\phi = \phi_1\wedge\phi_2$; or 
	\item $\satOnce (\omega, \phi_1)$ or $\satOnce (\omega, \phi_2)$ is true, when $\phi = \phi_1\vee\phi_2$; or
	\item $\satOnce (\omega, \phi_2)$ is true, when $\phi = \phi_1\U\phi_2$ or $\phi = \phi_1\R\phi_2$.
\end{itemize} 
\end{definition}

Based on Definition \ref{def:satOnce} and the semantics of \ltlf formulas, the lemma below is straightforward. 

\begin{lemma}\label{lem:satOnce}
Given an \ltlf formula $\phi$ and $\omega\in 2^{\P}$, $\satOnce (\omega, \phi)$ is true iff $\omega\models\phi$ holds.
\end{lemma}
In fact, Definition \ref{def:satOnce} can be considered as the simplified version of \ltlf semantics in which the length of the finite trace is restricted to be one. Also, Definition \ref{def:satOnce} provides a better option for the implementation purpose. 

\begin{theorem}\label{thm:winning-1}
Given an \ltlf formula $\phi$ with the alphabet $\X\cup \Y$, if there exists $Y\in 2^{\Y}$ such that $\satOnce (Y, \phi)$ is true, then $\phi$ is realizable. 
\end{theorem}
\begin{proof}
From Lemma \ref{lem:satOnce}, $\satOnce (Y, \phi)$ is true implies that $Y\models\phi$ is true. As a result, for every $X\in 2^{\X}$, it is true that $X\cup Y\models\phi$ is true, providing that $\X\cap \Y=\emptyset$. Therefore, there exists a strategy $g$ with $g(\epsilon) = Y$ such that for every $X\in 2^{\X}$ it holds that $X\cup g(\epsilon)\models\phi$. According to Definition \ref{def:synthesis}, $g$ is a winning strategy for the system and thus $\phi$ is realizable.
\end{proof}

Consider the formula $a\U b$ with $\X=\{a\}$ and $\Y=\{b\}$ as an example. Let $Y= \{b\}$ and since $\satOnce (Y, a\U b)$ is true, $\phi$ is realizable according to Theorem~\ref{thm:winning-1}. It is easy to induce that Theorem~\ref{thm:winning-1} can be extremely helpful for the synthesis instances like $\psi\U b$ with $\Y=\{b\}$, under which the realizable result can be achieved by Theorem~\ref{thm:winning-1} directly without further automata construction. This advantage may potentially lead to an exponential better performance, which is discussed in the experimental section. Next, we introduce the concept of \emph{formula projection} for the pre-processing of unrealizable formulas. 

\begin{definition}[Formula Projection]\label{def:fp}
Given an \ltlf formula $\phi$ in \NNF with the atomic set $P$, we define its projection under $P$, denoted as $\phi |_P$, is a Boolean formula as follows:
\begin{itemize}
	\item $\phi|_P = \phi$ if $\phi$ is $\tt$, $\ff$ or a literal;
	\item $\phi|_P = \tt$ iff $\phi = X\psi$ or $\phi = \N\psi$;
	\item $\phi|_P = \phi_1|_P \wedge \phi_2|_P$ if $\phi = \phi_1\wedge\phi_2$;
	\item $\phi|_P = \phi_1|_P \vee \phi_2|_P$ if $\phi = \phi_1\vee\phi_2$;
	\item $\phi|_P = \phi_1|_P \vee \phi_2|_P$ if $\phi = \phi_1\U\phi_2$;
	\item $\phi|_P = \phi_2|_P$ if $\phi = \phi_1\R\phi_2$.
\end{itemize}
\end{definition}

\begin{lemma}\label{lem:fp}
Given an \ltlf formula $\phi$ and a finite trace $\eta$, $\eta\models\phi$ implies that $\eta[0]\models\phi|_P$.
\end{lemma}
The proof can be done by induction over the types of $\phi$, which are omitted here. Lemma \ref{lem:fp} indicates that $\phi|_P$ is sufficient to capture all the first-position elements of $\phi$'s accepting traces. Inspired from that, we have the following lemma that can facilitate to identify a formula which is not realizable. 

\begin{theorem}\label{thm:failure-1}
Given an \ltlf formula $\phi$ with the atomic set $\X\cup \Y$, if $Y\models \phi|_{\X\cup\Y}$ does not hold for any $Y\in 2^{\Y}$, then $\phi$ is not realizable. 
\end{theorem}
\begin{proof}
Assume $\phi$ is realizable. According to Definition \ref{def:synthesis}, there exists a winning strategy $g$ such that for an arbitrary infinite sequence $X_0,X_1,\ldots\in {2^{\X}}^{\omega}$, we can find $k\geq 0$ such that $\rho=(X_0\cup g(\epsilon)),(X_1\cup g(X_0)), \ldots, (X_k\cup g(X_{k-1}))$ satisfies $\phi$. Let $Y = g(\epsilon)$, and based on Lemma \ref{lem:fp}, we have that $Y\cup X_0\models \phi|_{\X\cup\Y}$ for every $X_0\in 2^{\X}$. As the consequence, it is required that $Y\models \phi|_{\X\cup\Y}$ is true. However, we already know that $Y\models \phi|_{\X\cup\Y}$ does not hold for any $Y\in 2^{\Y}$, which causes the contradiction. Therefore, we prove that $\phi$ is not realizable.
\end{proof}

Consider the formula $\phi= \G (a\wedge b)\wedge \G (c\wedge d)$ with $\X=\{a,c\}$ and $\Y=\{b,d\}$ as an example. From Definition~\ref{def:fp}, we have that $\phi|_P=(a\wedge b\wedge c\wedge d)$. Obviously, $Y\models \phi|_P$ does not hold for any $Y\in 2^{\Y}$. We can conclude that $\phi$ is not realizable based on Theorem~\ref{thm:failure-1}. In general, the performance of the traditional synthesis approach for $\phi= \G (a\wedge b)\wedge \G (c\wedge d) \wedge\psi$ with $\X=\{a,c\}\cup P_{\psi}$ and $\Y=\{b,d\}$ (assume $P_{\psi}$ is the atomic set of $\psi$ and $P_{\psi} - \{a,b,c,d\} = P_{\psi}$) can decrease exponentially w.r.t. the size of $\psi$, while that of the synthesis based on Theorem \ref{thm:failure-1} can escape from the drawback. 

\begin{theorem}\label{thm:failure-2}
	Given an \ltlf formula $\phi$ with the atomic set $\X\cup \Y$, if there exists $X\in 2^{\X}$ such that $X\models \phi|_{\X\cup\Y}$ does not hold, then $\phi$ is not realizable. 
\end{theorem}
\begin{proof}
Assume $\phi$ is realizable. According to Definition \ref{def:synthesis}, there exists a winning strategy $g$ such that for an arbitrary infinite sequence $X_0,X_1,\ldots\in {2^{\X}}^{\omega}$, we can find $k\geq 0$ such that $\rho=(X_0\cup g(\epsilon)),(X_1\cup g(X_0)), \ldots, (X_k\cup g(X_{k-1}))$ satisfies $\phi$. Let $Y = g(\epsilon)$, and based on Lemma \ref{lem:fp}, we have that $Y\cup X_0\models \phi|_{\X\cup\Y}$ for every $X_0\in 2^{\X}$. However, we already have that there exists $X\in 2^{\X}$ (Let $X_0$ be such $X$) such that $X\not\models \phi|_{\X\cup\Y}$ holds, which implies that $X\cup Y\models \phi|_{\X\cup\Y}$ does not hold for any $Y\in 2^{\Y}$. This contradicts the assumption, leading to that $\phi$ is not realizable.
\end{proof}

Theorem \ref{thm:failure-2} can be treated as a stronger version of Theorem \ref{thm:failure-1}, since it is not hard to see that Theorem \ref{thm:failure-2} is true implies Theorem \ref{thm:failure-1} is true. For the example above ($\phi= \G (a\wedge b)\wedge \G (c\wedge d)$ with $\X=\{a,c\}$ and $\Y=\{b,d\}$), the unrealizable result can also be deduced from Theorem \ref{thm:failure-2}. Nonetheless, Theorem \ref{thm:failure-2} is kept in our implementation as it can cost less than Theorem \ref{thm:failure-1} to determine the unrealizability, considering that every $Y\in 2^{\Y}$ has to be enumerated in Theorem \ref{thm:failure-1} while enumerating every $X\in 2^{\X}$ may not be necessary in Theorem \ref{thm:failure-2}.


\section{On-the-fly Synthesis via \tdfa Games}
In this section, we first introduce the theoretic framework of the \ltlf synthesis via the \tdfa (Transition-based \dfa) game. Then we present an algorithm that generate the \tdfa on the fly to implement the synthesis. The definition of a \tdfa is shown as below. 
 
\begin{definition}[Transition-based \dfa]\label{def:tdfa}
The transition-based \dfa (\tdfa) $\mathcal{A}$ is a tuple $\A = (\Sigma,S,s_0,\delta,T)$ such that 
\begin{itemize}
    \item $\Sigma$ is the set of alphabet;
    \item $S$ is the set of states;
    \item $s_0\in S$ is the initial state;
    \item $\delta:S\times\Sigma\hookrightarrow S$ is the partial transition function, i.e. $\delta (s, \omega)\in S$ or $\delta (s, \omega)\in S$ is undefined for $s\in S$ and $\omega\in {\Sigma}$;
    \item $T \subseteq \delta$ is the set of accepting transitions.
\end{itemize}
\end{definition}

A run $r$ of $\A$ on a finite trace $\eta=\omega_0, \omega_1,\cdots, \omega_n \in \Sigma^+$ is a finite state sequence $s_0,s_1,\ldots,s_{n+1}$ such that $s_0$ is the initial state and $\delta (s_i, \omega_i) = s_{i+1}$ is true for $0\leq i \leq n$.
The trace $\eta$ is accepted by $\A$ iff the corresponding run $r$ ends with an accepting transition, i.e., $\delta (s_n, \omega_n) = s_{n+1}$ is in $T$. For the sake of simplicity, we denote $s_1\tran{\omega}s_2$ for the transition $\delta (s_1, \omega) = s_2$.

\begin{lemma}\label{lem:tdfa}
The \tdfa is as expressive as the \dfa.
\end{lemma}
\begin{proof}
	For the $\Leftarrow$ direction, a \dfa is trivially converted to its equivalent \tdfa by marking all transitions, whose target node is an accepting state of the \dfa, as the accepting transitions. For the $\Rightarrow$ direction, we first convert a \tdfa to its equivalent \nfa as follows: (1) Create a new state $f$ as the only accepting state of the \nfa; (2) Create a transition $s\tran{\omega}f$ if the transition $s\tran{\omega}s'$ is an accepting transition of the \tdfa. From the constructed \nfa, one can trivially generate the equivalent \dfa by the subset construction. 
\end{proof}


According to \cite{GV13}, there exists a \dfa for each \ltlf formula such that they accept the same language. Therefore, it is straightforward to see that there is also a \tdfa for each \ltlf formula such that they can accept the same language. 

In this paper, we present a dedicated \ltlf-to-\tdfa construction based on \SAT techniques below for on-the-fly synthesis. The \SAT-based automata construction was first introduced in \cite{LRPZV19}, and we follow the methodology presented in the literature. Given an \ltlf formula $\phi$, \cite{LRPZV19} provides a way to generate a \emph{propositional assignment} $A$ of $\phi$ such that $A$ includes the information of one transition for the \NFA generation. We refer readers to the literature for more details and here we simply use the notation $\SAT(\phi)$ ($=A$) to represent such process. Assume $A=\SAT(\phi)$ and let $L(A)$ denote the Boolean labels and $X(A)$ denote the successor state of the transition, the \tdfa construction can be achieved as follows.  

\begin{definition}[\ltlf-to-\tdfa]\label{def:ltlf2dfa}
Given an \ltlf formula $\phi$, the corresponding \TDFA ${\A_{\phi}}$ is defined as a tuple $(\Sigma, S, \delta, s_0, T)$ such that
\begin{itemize}
	\item $\Sigma = 2^{L}$ is the set of alphabet and $L$ is the literal set of $\phi$;
	\item $S\subseteq 2^{2^{\cl(\phi)}}$ is the set of states;
	\item $\delta:  S \times \Sigma \hookrightarrow S$ is the partial transition function, where $s_2 = \delta(s_1, \omega) (\omega \in \Sigma)$ holds iff $s_2=\{X(A) | A\in\{\SAT(s_1)\}\textit{ and }\omega \supseteq L(A)\}$;
	\item $s_0 = \{\{\phi \}\}$ is the initial state;
	\item $T\subseteq \delta$ is the set of accepting transitions. A transition $s_1\tran{\omega}s_2$ is in $T$ iff $\omega\models s_1$ holds. 
\end{itemize}

\end{definition}

The following theorem guarantees the correctness of the \tdfa construction shown in Definition \ref{def:ltlf2dfa}. 

\begin{theorem}
Given an \ltlf formula $\phi$ and the \tdfa ${\A_{\phi}}$ constructed by Definition \ref{def:ltlf2dfa}, a finite trace $\eta\models\phi$ holds iff $\eta$ is accepted by ${\A_{\phi}}$. 
\end{theorem}
The proof of this theorem requires more details from \cite{LRPZV19}, which are shown in the Appendix (\textcolor{red}{to be done ..}) section.
As soon as the \tdfa is constructed from the \ltlf formula, the synthesis problem is reducible to the \tdfa game defined as below.

\begin{definition}[\tdfa Game]\label{tdfa-game}
	A \tdfa game is specified by a \tdfa $\A = (2^{\X\times\Y}, S, s_0, \delta, T)$, where 
	\begin{itemize}
		\item $2^{\X\times\Y}$ is the alphabet of the game, where $\X$ and $\Y$ are two sets of variables whose values are controlled by the environment and controller respectively;
		\item $S$ is the set of states;
		\item $s_0$ is the initial state;
		\item $\delta:S\times 2^{\X\times\Y}\hookrightarrow S$ is the partial transition function, i.e. $\delta (s, X\cup Y)$ is in $S$ or  undefined for $s\in S$, $X\in 2^{\X}$ and $Y\in 2^{\Y}$;
    \item $T \subseteq \delta$ is the set of final transitions of the game, where the game can be considered terminated.
	\end{itemize}
\end{definition}
To coordinate with the \ltlf synthesis, we focus on the \textbf{Environment-first} \tdfa game as well. We say the game is \emph{winning} for the controller iff there is a winning strategy $f: (2^{\X})^*\rightarrow 2^{\Y}$ such that for an arbitrary infinite sequence $X_0,X_1,\ldots\in (2^{\X})^{\omega}$, there is $k\geq 0$ and the run of the \tdfa $\A$ on the trace $(X_0\cup f(\epsilon)), (X_1\cup f(X_0)),\ldots, (X_k\cup f(X_{k-1}))$ can lead to a final transition of $\A$.

 In the following, we define the \emph{winning} and \emph{failure} states of a \tdfa in terms of the \tdfa game.

\begin{definition}[Winning/failure State]\label{def:winning_failure_state}
\label{def:win_st}
Given a \tdfa $\A =(2^{\X\times \Y},S,s_0,\delta,T)$, we say $s\in S$ is a winning state iff there is $Y \in 2^\Y$ such that for every $X \in 2^\X$, either $\delta(s,X\cup Y)=s'$ is an accepting transition or $s'$ is a winning state. Moreover, we say $s$ is a failure state iff it is not a winning state.
\end{definition}

The following lemma is deducible from Definition \ref{def:winning_failure_state} instantly. 

\begin{lemma}
Given a \tdfa game $\A =(2^{\X\times \Y},S,s_0,\delta,T)$ and $s\in S$, 
\begin{enumerate}
	\item $s$ is a winning state if there is $Y \in 2^\Y$ such that for every $X \in 2^\X$, $\delta(s,X\cup Y)=s'$ is an accepting transition;
	\item $s$ is a failure state if for every $Y \in 2^\Y$, there is $X \in 2^\X$ such that $\delta(s,X \cup Y)$ is undefined.
\end{enumerate} 
\end{lemma}

Informally speaking, a winning state in the \tdfa is a state whose out-going transitions are defined, and the transitions are all accepting or lead to some winning states. To the opposite, a failure state is a state who has some out-going transitions undefined, or has a part of the transitions leading to the failure states. Now, we present the main theorem for our synthesis approach. 
%Based on Definitions \ref{def:winning_failure_state}, the follow theorem is also straightforward. 

\begin{theorem}\label{thm:winning-and-failure}
Given a \tdfa game $\A =(2^{\X\times \Y},S,s_0,\delta,T)$, $s_0$ is a winning state iff the controller is winning for the game.
\end{theorem}
\begin{proof}
\textcolor{red}{to be done.}
\end{proof}

An important question raises up that how do we know the initial state is a \emph{winning state}? Traditional synthesis approaches \cite{GV15} first construct the whole \dfa for the input formula, and then present a fixpoint calculation back from the accepting states, for the reason that those accepting states are obviously winning states. The calculation recursively marks the states that have a winning strategy to those winning states as winning, and terminates as soon as no more states can be marked. The controller is winning for the game if the initial state $s_0$ is in the computed winning set. The main drawback of such methodology is the winning strategy can only be computed after the \dfa is generated.  


\begin{algorithm}
\caption{\tool: Compute the winning strategy on the fly}
\label{alg:win}
	\begin{algorithmic}[1]
		\REQUIRE{An \ltlf formula $\phi$ with $\X$ and $\Y$;}
		\ENSURE{$\Omega=\{\langle s, Y, \{\langle X, s'\rangle\}\rangle\}$ if $\phi$ is realizable, otherwise return $\emptyset$;\COMMENT{\textcolor{blue}{$s,s'\in S$, $X\in 2^{\X}$ and $Y\in 2^{\Y}$}}}
		
		\STATE Let $\langle ret, \Omega\rangle\coloneqq preprocess(\phi, \X, \Y)$;\COMMENT{\textcolor{blue}{Check by the pre-processing techniques at first}}\label{alg:win:preprocess-start}
		\IF{$ret\neq unknown$}
    		\RETURN $\Omega$;
    	\ENDIF\label{alg:win:preprocess-end}
    	\WHILE{true\COMMENT{\textcolor{blue}{Enumerate $Y$ inside}}}\label{alg:win:Yloop-start}
    		\STATE $\langle \omega,s\rangle\coloneqq getTransition(\phi,\emptyset)$;\COMMENT{\textcolor{blue}{Get the transition $\phi\tran{\omega}s$}}
    		\IF{$\langle \omega,s\rangle =\emptyset$}
        		\RETURN $\emptyset$;
    		\ENDIF
    	\STATE Let $\phi'\coloneqq \phi$ and $r \coloneqq \langle \phi, Y=\omega|_{\Y}, Q=\{\langle \omega|_{\X}, s\rangle\}\rangle$;
    	\STATE Push $r$ into $\Omega$;
    	\WHILE{true\COMMENT{\textcolor{blue}{Fix $Y=\omega|_{\Y}$, enumerate $X$ inside}}}\label{alg:win:Xloop-start}
        	\IF{$s$ has been generated\COMMENT{\textcolor{blue}{A loop is detected}}}\label{alg:win:loop-detect}
            	\BREAK;\COMMENT{\textcolor{blue}{The chosen $Y$ is not OK}}
            \ENDIF
        	\IF{$\omega\models \phi'$\COMMENT{\textcolor{blue}{An accepting transition is detected}}}
            	\STATE $\phi'\coloneqq \phi'\wedge(\neg(\omega|_{\X}))$;\COMMENT{\textcolor{blue}{Enumerate $X$}}
        	\ELSE
            	\STATE Let $\Omega'\coloneqq \tool(s, \X, \Y)$;\label{alg:win:recursive}
            	\IF{$\Omega'\not = \emptyset$\COMMENT{\textcolor{blue}{$s$ is a winning state}}}	
                	\STATE $\phi'\coloneqq \phi'\wedge(\neg(\omega|_{\X}))$;\COMMENT{\textcolor{blue}{Enumerate $X$}}
            	\ELSE
                	\BREAK;\COMMENT{\textcolor{blue}{The chosen $Y$ is not OK}}
            	\ENDIF
        
        	\ENDIF
        	\STATE $\langle\omega',s'\rangle\coloneqq getTransition(\phi',\omega|_\Y)$;\COMMENT{\textcolor{blue}{Get the transition $\phi\tran{\omega'}s'$ such that $\omega|_{\Y}\subseteq \omega'$}}
        	\IF{$\langle\omega',s'\rangle=\emptyset$\COMMENT{\textcolor{blue}{Enumerating $X$ is finished}}}
            	\RETURN $\Omega$;\label{alg:win:loop-stop}
            \ELSE
            	\STATE Update $r=\langle \phi, Y, Q\rangle$ by pushing $\langle \omega'|_{\X}, s'\rangle$ into $Q$;
        	\ENDIF
    	\ENDWHILE\label{alg:win:Xloop-end}
    	\STATE Remove $r$ from $\Omega$;
    	\STATE $\phi\coloneqq \phi\wedge(\neg(\omega|_{\Y}))$;\COMMENT{\textcolor{blue}{Enumerate $Y$}}\label{alg:win:chooseY}
	\ENDWHILE\label{alg:win:Yloop-end}
	\end{algorithmic}
\end{algorithm}

In this paper, we present a new technique that compute the winning strategy on the fly. The algorithm \tool, which is shown in Algorithm \ref{alg:win}, describes the main procedures of the new technique. While comments are blue-colored in the body to help understand the algorithm, we summarize the crucial parts of the technique as follow.

The algorithm $\tool$ takes a tuple $(\phi, \X, \Y)$ as the input and outputs a set $\Omega$ which contains the winning strategy information if exists, or an empty set. Each element of $\Omega$ has the form of $\langle s, Y, \{\langle X, s'\rangle\}\rangle$, where $s,s'\in S$, $X\in 2^{\X}$ and $Y\in 2^{\Y}$. Such element indicates that from state $s$, the winning action for the controller is $Y$ for an arbitrary $X$. Moreover, Given an $X\in 2^{\X}$, it also tells the next state for the controller to win is $s'$, i.e., $s\tran{X\cup Y}s'$ is a transition of the \tdfa and $s'$ is a winning state as well.

\tool starts with the preprocessing techniques from Line \ref{alg:win:preprocess-start} to \ref{alg:win:preprocess-end}. The \emph{preprocess} function implements Theorem \ref{thm:sat-syn}-\ref{thm:failure-2}, and $\tool$ returns immediately if the function succeeds to determine $\phi$ is a winning or failure state. The loop between Line \ref{alg:win:Yloop-start} to \ref{alg:win:Yloop-end} aims to enumerate $Y\in 2^{\Y}$ inside, and it can terminate as soon as a winning action $Y$ for the controller is found (at Line \ref{alg:win:loop-stop}). Meanwhile, the loop between Line \ref{alg:win:Xloop-start} to \ref{alg:win:Xloop-end} has to enumerate every $X\in 2^{\X}$ before it can conclude the fixed $Y$ is indeed a winning action for the controller. If the enumeration on $X$ is not successful, another $Y$ has to be chosen (at Line \ref{alg:win:chooseY}) and the above process repeats.

There are two points that need to be addressed clearly in the algorithm. Firstly, if the new transition $\phi\tran{\omega}s$ is not an accepting transition, $\tool$ will be invoked on $s$ recursively to determine whether $s$ is a winning state (at Line \ref{alg:win:recursive}). Secondly, if a loop is detected before $s$ can be determined as the winning state for the controller (at Line \ref{alg:win:loop-detect}), $s$ can never be a winning state. Assume the run of the \tdfa is $r=s,s_1,\ldots, s$. Starting from $s$, the environment can have the option to induce the same run as $r$, in which case the controller can never win.  


\iffalse
\begin{algorithm}
\caption{\tool: On-the-fly \ltlf Synthesis}
\label{algo:newSyn}
	\begin{algorithmic}[1]
		\REQUIRE{An \ltlf formula $\phi$ with $\X$ and $\Y$;}
		\ENSURE{Realizable or Unrealizable;}
		
		\STATE Let $ret\coloneqq preprocess(\phi, \X, \Y)$;
		\IF{$ret\neq unknown$}
    		\RETURN $ret$;
    	\ENDIF
    	\WHILE{true}
    		\STATE $\langle \omega,s\rangle\coloneqq getTransition(\phi,\emptyset)$;
    		\IF{$\langle \omega,s\rangle =null$}
        		\RETURN Unrealizable;
    		\ENDIF
    	\STATE Let $\phi'\coloneqq \phi$;
    	\WHILE{true\COMMENT{\textcolor{blue}{Fix $Y=\omega|_{\Y}$, enumerate $X$ inside}}}
        	\IF{$s$ has been generated\COMMENT{\textcolor{blue}{A loop is detected}}}
            	\BREAK;\COMMENT{\textcolor{blue}{The chosen $Y$ is not OK}}
            \ENDIF
        	\IF{$\omega\models \phi'$\COMMENT{\textcolor{blue}{An accepting transition is detected}}}
            	\STATE $\phi'\coloneqq \phi'\wedge(\neg(\omega|_{\X}))$;\COMMENT{\textcolor{blue}{Enumerate $X$}}
        	\ELSE
            	\STATE $result\coloneqq \tool(s, \X, \Y)$;
            	\IF{$result=Realizable$\COMMENT{\textcolor{blue}{$s$ is a winning state}}}	
                	\STATE $\phi'\coloneqq \phi'\wedge(\neg(\omega|_{\X}))$;\COMMENT{\textcolor{blue}{Enumerate $X$}}
            	\ELSE
                	\BREAK;\COMMENT{\textcolor{blue}{The chosen $Y$ is not OK}}
            	\ENDIF
        
        	\ENDIF
        	\STATE $\langle\omega,s\rangle\coloneqq getTransition(\phi',\omega|_\Y)$;
        	\IF{$\langle\omega,s\rangle=null$\COMMENT{\textcolor{blue}{Enumerating $X$ is finished}}}
            	\RETURN Realizable; 
        	\ENDIF
    	\ENDWHILE
    	\STATE $\phi\coloneqq \phi\wedge(\neg(\omega|_{\Y}))$;\COMMENT{\textcolor{blue}{Enumerate $Y$}}
	\ENDWHILE
	\end{algorithmic}
\end{algorithm}
\fi


\begin{algorithm}
\caption{Implementation of function \emph{getTransition}}
	\begin{algorithmic}[1]
	\REQUIRE{An \ltlf formula $\phi$, and a set of literals $assumption$;}
	\ENSURE{$\langle label,next\rangle$ such that $\phi\tran{label}next$ is a transition of the \tdfa, otherwise return $\emptyset$;}
	
	\STATE Let $label\coloneqq null$, $next \coloneqq null$;
	\STATE Let $\phi\coloneqq \phi\wedge\left(\bigwedge assumption\right)$;
	 \WHILE{true\COMMENT{\textcolor{blue}{Find $label$ such that $Y=label|_{\Y}$ satisfies $Y\models\phi|_{\X\cup\Y}$}}}
    	\STATE Let $A = \SAT (\phi)$;
    	\IF{$A=\emptyset$}
    		\BREAK;
    	\ENDIF
    	\IF{$A|_\Y\models \phi|_{\X\cup\Y}$}
        	\STATE $label\coloneqq L(A)$;
        	\STATE $next\coloneqq X(A)$;
        	\BREAK;\COMMENT{\textcolor{blue}{$Y=A|_{\Y}$ is found}}
    	\ENDIF
    	\STATE $\phi\coloneqq \phi\wedge\left(\neg\bigwedge A|_\Y\right)$;
	\ENDWHILE
	\STATE $\phi\coloneqq \phi\wedge label\wedge(\neg next)$;
	\WHILE{true\COMMENT{\textcolor{blue}{Fix $label$ and generate the successor state of $\phi$ in the \tdfa}}}
    	\STATE Let $A = \SAT(\phi)$;
    	\IF{$A=\emptyset$}
    		\BREAK;
    	\ENDIF
    	\STATE $next\coloneqq next\vee X(A)$;
    	\STATE $\phi\coloneqq \phi\wedge(\neg (X(A)))$;
	\ENDWHILE
	\IF{$label=null$ or $next=null$}
		\RETURN $\emptyset$;
	\ENDIF
	\RETURN $\langle label,next\rangle$;
	\end{algorithmic}
\end{algorithm}


Let $\Omega = \tool (\phi, \X, \Y)$ and we now define the strategy generator based on $\Omega$. 

\begin{definition}[Strategy Generator]\label{def:transducer}
	The strategy generator for the \ltlf synthesis problem $(\phi, \X, \Y)$ is a transducer $\mathcal{T}_{\A}=(2^{\X\times\Y}, S, s_0, \rho, \sigma)$ such that
	\begin{itemize}
		\item $2^{\X\times\Y}$ is the alphabet of the transducer;
		\item $S = \{s| \langle s, Y, \{\langle X, s'\rangle\}\rangle \in\Omega\}\subseteq 2^{2^{\cl(\phi)}}$ is the set of states;
		\item $s_0 = \{\{\phi\}\}$ is the initial state;
		\item $\rho: S\times 2^{\X}\rightarrow 2^S$ is the transition function such that $\rho (s, X) = \{s' | \langle s, Y, \{\langle X, s'\rangle\}\rangle\in \Omega\}$;
		\item $\sigma: S\rightarrow 2^{\Y}$ is the output function such that $\sigma(s)=\{Y | \langle s, Y, \{\langle X, s'\rangle\}\rangle \in \Omega\}$.
	\end{itemize}
\end{definition}


\iffalse
\begin{theorem}
Given a TDFA $\mathcal{A} =(2^{\X \cup \Y}, S, s_0, \delta, T)$ and a sub-TDFA $\mathcal{A}' =(2^{\X \cup \Y},$ $S',s_0,\delta',T')$ where $S'\subseteq S$, $\delta'\subseteq \delta$ and $T'\subseteq T$, if $\mathcal{A}'$ has a winning strategy, then $\mathcal{A}$ also has a winning strategy. 

\textbf{Comments: } To convince this theorem, we need to note that a winning strategy is a mapping ${(2^\X)}^*\to 2^\Y$ and the "\textbf{for every $X \in 2^\X$}" in definition~\ref{def:win_st}. Suppose sub-TDFA $\mathcal{A}'$ has a winning strategy, let us consider winning state $w$ of $\mathcal{A}'$. Starting from $w$, there exists $Y \in 2^\Y$ such that for every $X \in2^\X$, $(w, X \cup Y)$ will lead to winning. For example, if $|\X| = 2$ and we calculate that $Y = 01$ can satisfy the condition, then the moves $X \cup Y$ that satisfies the condition can be 0001, 0101, 1001 or 1101, i.e. combination of $2^\X$ and $y=01$. Therefore, if a state of sub-TDFA $\mathcal{A}'$ is judged as winning state, it should also be winning state in $\mathcal{A}$.
\end{theorem}

\begin{theorem}
Given a TDFA $\mathcal{A} =(2^{\X \cup \Y}, S, s_0, \delta, T)$, we get the TDFA $\mathcal{A}'$ by removing failure states and transitions related to failure states from $\mathcal{A}$. $\mathcal{A}$ has a winning strategy iff $\mathcal{A}'$ has a winning strategy.
\end{theorem}
\fi


\iffalse
\begin{algorithm}[h]
\Large
\caption{Declare and Initialize Global Variables}
\label{algo:init}
Global $S=\emptyset$;   \tcp{the set of automaton states}
Global $\delta=\emptyset$;  \tcp{the set of automaton transitions}
Global $winning\_state\coloneqq\emptyset$\;
Global $failure\_state\coloneqq\emptyset$\;
Global $to\_expand \coloneqq\emptyset$\;
\end{algorithm}

\begin{algorithm}[h]
\Large
\caption{On-the-Fly $LTL_f$ synthesis}
\label{algo:syn}
\KwIn{$LTL_f$ formula $f$}
\KwOut{True or False}
$to\_expand \coloneqq\{f\}$\;
\While{$to\_expand\neq\emptyset$}
{
    get and remove $\phi$ from $to\_expand$\;
    $<new\_state,new\_trans>\coloneqq expand(\phi)$\;
    $S\coloneqq S\cup new\_state$\;
    $\delta\coloneqq \delta\cup new\_trans$\;
    \If{is\_winning($\phi$)}
    {
        compute\_winning\_state($\phi$)\;
        \If{$f\in winning\_state$}
        {
            return True\;
        }
    }
    \ElseIf{is\_failure($\phi$)}
    {
        compute\_failure\_state($\phi$)\;
        \If{$f\in failure\_state$}
        {
            return False\;
        }
        
    }
}
return False\;   

\end{algorithm}


\begin{algorithm}[h]
\Large
\caption{expand}
\label{algo:expand}
\KwIn{$LTL_f$ formula $f$}
\KwOut{$new\_state$, $new\_trans$}
$new\_state\coloneqq\emptyset$\;
$new\_trans\coloneqq\emptyset$\;
$f'\coloneqq f^p$\;
let $label\_next$ be a map\;
\While{$f'$ is satisfiable}
{
    get a model $A$ of $f'$\;
    get $<Label,Next>$ from $A$\;
    \If{$label\_next[Label]=NULL$}
    {
        $label\_next[Label]\coloneqq Next$\;
    }
    \Else
    {
        $label\_next[Label]\coloneqq label\_next[Label]\vee Next$\;
    }
    $f'\coloneqq f'\wedge(\neg(\wedge A))$\;
}
\For{$<Label,Next>$ in $label\_next$}
{
    $new\_state\coloneqq new\_state\cup\{Next\}$\;
    $new\_trans\coloneqq new\_trans\cup\{f\times Label\to Next\}$\;
}
return $new\_state$, $new\_trans$\;
\end{algorithm}

\begin{algorithm}[h]
\Large
\caption{is\_winning}
\label{algo:is_win}
\KwIn{an expanded state $s$}
\KwOut{True or False}
$trans\coloneqq\{s_1\times\omega\to s_2\in\delta|\ s_1=s\}$\;
\For{$y$ in $2^Y$}
{
    $flag\coloneqq True$\;
    \For{$x$ in $2^X$}
    {
        \If{$((s_1\times (x\cup y)\to s_2\notin trans)$ $\vee((s_1\times (x\cup y)\to s_2\ is\ not\ accepting)\wedge(\delta(s_1,x\cup y)\notin winning\_state)))$}
        {
            $flag\coloneqq False$\;
            break\;
        }
    }
    \If{$flag=True$}
    {
        return True\;
    }
    
}
return False\;
\end{algorithm}

\begin{algorithm}[h]
\Large
\caption{is\_failure}
\label{algo:is_fail}
\KwIn{an expanded state $s$}
\KwOut{True or False}
$trans\coloneqq\{s_1\times\omega\to s_2\in\delta|\ s_1=s\}$\;
\For{$y$ in $2^Y$}
{
    $flag\coloneqq True$\;
    \For{$x$ in $2^X$}
    {
        \If{$(s_1\times (x\cup y)\to s_2\notin trans)\vee(s_1\times (x\cup y)\to s_2\ is\ not\ accepting\wedge\delta(s_1,x\cup y)\in failure\_state)$}
        {
            $flag\coloneqq False$\;
            break\;
        }
    }
    \If{$flag=True$}
    {
        return False\;
    }
}
return True\;
\end{algorithm}

\begin{algorithm}[h]
\Large
\caption{compute\_winning\_state}
\label{algo:comput_win}
\KwIn{a new winning state: $w$}
$winning\_state\coloneqq winning\_state\cup\{w\}$\;
$new\_win\coloneqq \{w\}$\;
\While{$new\_win\neq \emptyset$}
{
    get and remove $s$ from $new\_win$\;
    $predecessor\coloneqq\{p|p\times\omega\to s\in \delta\}$\;
    \For{p in $predecessor$}
    {
        \If{is\_winning(p)}
        {
            $winning\_state\coloneqq winning\_state\cup\{p\}$\;
            $new\_win\coloneqq new\_win\cup\{p\}$\;
        }
    }
}
\end{algorithm}

\begin{algorithm}[h]
\Large
\caption{compute\_failure\_state}
\label{algo:comput_fail}
\KwIn{a new failure state: $f$}
$failure\_state\coloneqq failure\_state\cup\{f\}$\;
$new\_fail\coloneqq \{f\}$\;
remove $f$ from $to\_expand$\;
\While{$new\_fail\neq \emptyset$}
{
    get and remove $s$ from $new\_fail$\;
    $predecessor\coloneqq\{p|p\times\omega\to s\in \delta\}$\;
    \For{p in $predecessor$}
    {
        \If{is\_failure(p)}
        {
            $failure\_state\coloneqq failure\_state\cup\{p\}$\;
            $new\_fail\coloneqq new\_fail\cup\{p\}$\;
            remove $p$ from $to\_expand$\;
        }
    }
}
\end{algorithm}
\fi




