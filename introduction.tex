\section{Introduction}\label{sec:intro}
Synthesis for Linear Temporal Logic over finite traces, i.e., \ltlf\citep{GV13}, has emerged as a popular research topic in the AI community due to applications such as motion planning \citep{ZGPV20,R04}.  
\ltlf is a formal logic that has received considerable concerns from the AI community, due to its simplicity and ability to formalize and validate behaviors of AI systems \cite{GV13,GV15}. %MYV: Add citations for this,
While standard Linear Temporal Logic~(\ltl) is interpreted on infinite traces~\citep{Pnu77}, \ltlf is interpreted over finite traces \citep{GV13}. Since first introduced in 2013, the fundamental problems of \ltlf, e.g., satisfiability \citep{LZPVH14,LRPZV19} and synthesis \citep{GV15,ZTLPV17}, have been extensively studied in prior work. Towards applications, researchers successfully reduced the planning problem with \ltlf goals to the synthesis problem for \ltlf \citep{CTMBM17,CBM18,AGMR18,AGMR19,ZGPV20}, which makes the logic very attractive in this domain. We focus on \ltlf synthesis in this paper.   

Given an \ltlf formula $\phi$ with input/output atomic proposition sets $\X,\Y$ such that $\X\cap \Y=\emptyset$ and $\P=\X\cup\Y$ is the set of atomic propositions of $\phi$, the synthesis problem asks whether every finite trace generated as the result of a game between the environment controlling the input propositions and the system controlling the output propositions can satisfy the formula $\phi$ (see Definition \ref{def:synthesis} for details). Extant solutions rely on a reduction from \ltlf synthesis to \dfa (Deterministic Finite Automata) game~\citep{GV15}. Explicitly, the \dfa that recognizes the same language as the \ltlf formula has to be constructed at first. Then a backward fixpoint calculation is performed on the generated \dfa from the set of accepting states. The calculation initially marks the accepting states as the \emph{winning} states, and recursively extends this winning set based on the current information. If finally the initial state of the \dfa is included in the winning set, we conclude that the formula $\phi$ is realizable w.r.t. the input/output sets $\X$ and $\Y$. Otherwise, the formula is unrealizable. It is well-known that the \ltlf-to-\dfa translation is the most demanding part of the computation, as the size of the generated \dfa can be doubly exponential to the size of the formula \citep{KV01d}. Indeed, the \dfa construction is the main bottleneck in the current approach \cite{ZTLPV17}.

Several optimizations for \dfa construction have been proposed. \citep{ZTLPV17} has shown using \mona \citep{HJJKPRS95,EKM98} to symbolically construct the minimal \dfa can be much faster than using \spot \citep{DP04}, which employs an explicit construction. Later, \citep{ZhuPV19} performed an extensive comparison over different encodings from \ltlf to the input format of \mona to look for the best-performing encoding, and showed the outperformance of First Order Logic~(FOL) encoding. \citep{TV19} introduced a partitioning technique to decompose the generation of a large \dfa into small ones \citep{MSL18}. Recently, \citep{BLTV20} combined both of the explicit and symbolic \dfa state-space representations and successfully achieved a better \dfa construction than those using only one single representation. Nonetheless, none of these techniques above can avoid the double exponential-up cost, as the \dfa construction is the indispensable part for \ltlf synthesis. Therefore, the question arises up whether it is possible to solve \ltlf synthesis without generating the whole \dfa.

We present here a novel approach to achieve this goal. First of all, we present three light-weight pre-processing techniques for \ltlf synthesis, which can be easily implemented and with low running-cost. Notably, such pre-processing techniques can be performed directly on the input formula even without constructing the \dfa. As a result, they can be integrated into all other available \ltlf synthesis approaches. Secondly, we propose a new synthesis framework that is based on \dfa construction \emph{on the fly}, i.e., the \dfa states are created only as necessary. We start from the initial state $s_0$ (that is the input formula $\phi$ under our framework) and then proceed forward to continuously generate successor states when necessary. As soon as the new created state is determined as \emph{winning/failure}, a backtrack procedure is invoked to determine whether the predecessors are winning/failure based on stored information. As soon as the initial state can be determined as winning (resp. failure), the realizable (resp. unrealizable) result can be concluded. In the worst case, the algorithm returns unrealizable when the whole \dfa is constructed. 

We conducted extensive experimental evaluations on both the pre-processing techniques and the new synthesis framework, by comparing to extant \ltlf synthesis tools \syft~\citep{ZTLPV17} and \lisasyft \citep{BLTV20}. Results show that: (1) the pre-processing techniques can speed-up the synthesis with up to an exponentially better performance; (2) the new synthesis framework via on-the-fly \dfa construction is able to complement the extant ones by uniquely solving a significant number of instances. 